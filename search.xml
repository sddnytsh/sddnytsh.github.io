<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>文件处理</title>
      <link href="/2025/05/05/%E8%8B%B1%E8%AF%AD/"/>
      <url>/2025/05/05/%E8%8B%B1%E8%AF%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="a">A</h1><h1 id="b">B</h1><h1 id="c">C</h1><h1 id="d">D</h1><h1 id="e">E</h1><p>eligible 有资格的<br>be eligible for sth./to do sth.</p><h1 id="f">F</h1><h1 id="g">G</h1><h1 id="h">H</h1><h1 id="i">I</h1><h1 id="j">J</h1><h1 id="k">K</h1><h1 id="l">L</h1><h1 id="m">M</h1><h1 id="n">N</h1><h1 id="o">O</h1><h1 id="p">P</h1><h1 id="q">Q</h1><h1 id="r">R</h1><h1 id="s">S</h1><h1 id="t">T</h1><h1 id="u">U</h1><h1 id="v">V</h1><h1 id="w">W</h1><h1 id="x">X</h1><h1 id="y">Y</h1><h1 id="z">Z</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML</title>
      <link href="/2025/04/17/html/"/>
      <url>/2025/04/17/html/</url>
      
        <content type="html"><![CDATA[<h1 id="html简介">HTML简介</h1><p>超文本标记语言(HyperText Markup Language)是一种用于创建网页的标准标记语言。它不是一种编程语言，而是一种标记语言，标记语言是一套标记标签。HTML就是使用标记标签来描述网页。</p><p>HTML文档后缀可以是.htm，也可以是.html。</p><p>HTML 标签是由尖括号包围的关键词，比如 &lt;html&gt;。标签通常是成对出现的，比如&lt;b&gt;和&lt;/b&gt;，第一个出现的是开始标签，第二个则是结束标签。</p><h1 id="web浏览器">Web浏览器</h1><p>Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。</p><p>浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户。</p><p>值得一提的是只有&lt;body&gt;区域才会在浏览器显示。</p><h1 id="a-href-https-developer-mozilla-org-zh-cn-docs-learn-web-development-core-structuring-content-html基础-a"><a href="https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Structuring_content">HTML基础</a></h1>]]></content>
      
      
      <categories>
          
          <category> -HTML </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Node.js</title>
      <link href="/2025/04/17/nodejs/"/>
      <url>/2025/04/17/nodejs/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是node-js">什么是node.js</h1><p>Node.js是JavaScript语言的服务器运行环境。它允许开发者在服务器端运行 JavaScript 代码。</p><h1 id="npm">npm</h1><p>npm(node package manager)是Node的包管理工具，会随着Nodejs一起安装，能解决NodeJS代码部署上的很多问题。到目前为止，npm差不多收集了60w个别人写好的包，每个包就是一个功能，一个需求，npm里面有关于创建服务器的包，启动电脑摄像头的包，如果正好我们有这些需求，那么我们就没必要自己去写代码，完全可以用别人已经写好的包。<br>可以通过&quot;npm -v&quot;来测试是否成功安装<br><img src="/img/nodejs/npm-v.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> -javascript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树状数组</title>
      <link href="/2025/04/17/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2025/04/17/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是树状数组-binary-indexed-tree-bit">什么是树状数组(Binary Indexed Tree, BIT)</h1><p>顾名思义就是一个结构为树形结构的数组，与二叉树的结构类似但又不同，它是在二叉树的结构上删除了一些中间节点。<br><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84.png" alt=""><br>t[x]保存以x为根的子数中叶子节点值的和,原数组为a[]。<br>它可以解决大部分区间上面的修改以及查询的问题，例如单点修改，单点查询，区间修改，区间查询，换言之，线段树能解决的问题，树状数组大部分也可以，但是并不一定都能解决，因为线段树的扩展性比树状数组要强。</p><h1 id="树状数组讲解">树状数组讲解</h1><h2 id="lowbit-x">lowbit(x)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int lowbit(x)&#123;</span><br><span class="line">    return x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是补码，所以该函数可以计算x的二进制表示中最右边的 1 所代表的值。<br>我们可以发现节点x的父节点为x + lowbit(x)</p><h2 id="单点修改">单点修改</h2><p>如果我们在单点修改的同时，更新父节点就变得尤为简单。我们要实现a[1]+k，那么t[1],t[2],t[4],t[8]都要 + k;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int add(int x, int k)&#123;</span><br><span class="line">    for(int i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">        t[i] += k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间查询">区间查询</h2><p><img src="/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2.png" alt=""><br>通过图片，可以看到sum[7] = t[7] + t[6] + t[4]，6 = 7 - lowbit(7), 4 = 6 - lowbit(6)，所以我们可以通过不断的-lowbit()来实现求和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int ask(int x)&#123;</span><br><span class="line">    int sum = 0;</span><br><span class="line">    for(int i = x; i; i -= lowbit(i))&#123;</span><br><span class="line">        sum += t[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这只能求[1, x]的区间和，那么如何求[L, R]的区间和呢，可以利用[L, R] = [1, R] - [1, L - 1]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int search(int L,int R)</span><br><span class="line">&#123;</span><br><span class="line">int ans = 0;</span><br><span class="line">for(int i=L-1;i;i-=lowbit(i))</span><br><span class="line">ans-=c[i];</span><br><span class="line">for(int i=R;i;i-=lowbit(i))</span><br><span class="line">ans+=c[i];</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间修改">区间修改</h2><p>对区间[L, R] + k，利用差分数组性质，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int update(int x,int k)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=x;i&lt;=n;i+=lowbit(i))</span><br><span class="line">c[i]+=k;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">update(L,k);</span><br><span class="line">update(R+1,-k);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>之后想更新的内容</title>
      <link href="/2025/04/16/%E4%B9%8B%E5%90%8E%E6%83%B3%E6%9B%B4%E6%96%B0%E7%9A%84%E5%86%85%E5%AE%B9/"/>
      <url>/2025/04/16/%E4%B9%8B%E5%90%8E%E6%83%B3%E6%9B%B4%E6%96%B0%E7%9A%84%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件处理</title>
      <link href="/2025/04/13/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"/>
      <url>/2025/04/13/%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="文件流类">文件流类</h1><p>ifstream(读操作)<br>ofstream(写操作)<br>fstream(读写操作)</p><h1 id="写文件">写文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;fstream&gt;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(&quot;文件路径&quot;,打开方式);</span><br><span class="line">ofs&lt;&lt;&quot;...&quot;;</span><br><span class="line">ofs.close();</span><br></pre></td></tr></table></figure><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件打开</td></tr><tr><td>ios:out</td><td>为写文件打开</td></tr><tr><td>ios::ate</td><td>初始位置在文件尾</td></tr><tr><td>ios:app</td><td>追加方式写文件</td></tr><tr><td>ios:trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><h1 id="读文件">读文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;fstream&gt;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(&quot;文件路径&quot;,打开方式);</span><br><span class="line">char buffer[1024];</span><br><span class="line">while(ifs.read(buffer, sizeof(buffer) - 1))&#123;</span><br><span class="line">    buffer[ifs.gcount()]=&#x27;\0&#x27;;</span><br><span class="line">    cout&lt;&lt;buffer;</span><br><span class="line">    memset(buffer, 0, sizeof(buffer));</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><h1 id="检索文件">检索文件</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;fstream&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; findSentencesWithKeyword(const string&amp; filename, const string&amp; keyword) &#123;</span><br><span class="line">    vector&lt;string&gt; sentences;</span><br><span class="line">    ifstream infile(filename); </span><br><span class="line">    if (!infile) &#123;</span><br><span class="line">        cerr &lt;&lt; &quot;无法打开文件: &quot; &lt;&lt; filename &lt;&lt; endl;</span><br><span class="line">        return sentences;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string line;</span><br><span class="line">    while (getline(infile, line)) &#123; </span><br><span class="line">        istringstream iss(line); </span><br><span class="line">        string sentence;</span><br><span class="line">        while (getline(iss, sentence, &#x27;.&#x27;)) &#123; // 按句号分割句子</span><br><span class="line">            if (sentence.find(keyword) != string::npos) &#123; </span><br><span class="line">                sentences.push_back(sentence + &quot;.&quot;); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    infile.close(); </span><br><span class="line">    return sentences;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    string filename;</span><br><span class="line">    cout &lt;&lt; &quot;请输入文件名: &quot;;</span><br><span class="line">    cin &gt;&gt; filename;</span><br><span class="line"></span><br><span class="line">    string keyword;</span><br><span class="line">    cout &lt;&lt; &quot;请输入关键词: &quot;;</span><br><span class="line">    cin &gt;&gt; keyword;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; sentences = findSentencesWithKeyword(filename, keyword); </span><br><span class="line"></span><br><span class="line">    if (sentences.empty()) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;未找到包含关键词的句子。&quot; &lt;&lt; endl;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; &quot;按回车键显示下一个包含关键词的句子，输入 &#x27;q&#x27; 退出。&quot; &lt;&lt; endl;</span><br><span class="line">    char input;</span><br><span class="line">    for (size_t i = 0; i &lt; sentences.size(); ++i) &#123;</span><br><span class="line">        cin.get(input); // 等待用户输入</span><br><span class="line">        if (input == &#x27;q&#x27;) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;找到句子: &quot; &lt;&lt; sentences[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>回溯</title>
      <link href="/2025/04/12/%E5%9B%9E%E6%BA%AF/"/>
      <url>/2025/04/12/%E5%9B%9E%E6%BA%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="回溯算法的核心思想">回溯算法的核心思想</h1><ul><li>选择：从当前状态出发，选择一个可能的候选解。</li><li>约束条件：判断当前选择是否满足约束条件。</li><li>递归：如果当前选择满足约束条件，递归地进行下一步选择。</li><li>回溯：如果当前选择不满足约束条件，或者已经到达问题的解空间的叶子节点，回溯到上一步，尝试其他选择。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(状态)&#123;</span><br><span class="line">    if(当前状态是解)&#123;</span><br><span class="line"></span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if(到解空间的叶子节点)return;</span><br><span class="line">    for(每个可能的解)&#123;</span><br><span class="line">        if(选择约束条件)&#123;</span><br><span class="line">            改变状态;</span><br><span class="line">            backtrack(下一个状态);</span><br><span class="line">            还原状态;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排列问题">排列问题</h1><p>问题描述：给定一个数组，生成所有可能的排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">void backtrack(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; path, vector&lt;bool&gt;&amp; used, vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123;</span><br><span class="line">    if (path.size() == nums.size()) &#123;</span><br><span class="line">        result.push_back(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        if (used[i]) continue; // 如果当前数字已经被使用，跳过</span><br><span class="line">        path.push_back(nums[i]); // 做出选择</span><br><span class="line">        used[i] = true;</span><br><span class="line">        backtrack(nums, path, used, result); // 递归</span><br><span class="line">        path.pop_back(); // 撤销选择</span><br><span class="line">        used[i] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="路径之谜">路径之谜</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const int dx[4] = &#123;0, 1, 0, -1&#125;;</span><br><span class="line">const int dy[4] = &#123;1, 0, -1, 0&#125;;</span><br><span class="line">bool DFS(int x, int y, int n, int m, vector&lt;vector&lt;int&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited) &#123;</span><br><span class="line">    if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m) return false;</span><br><span class="line">    if (visited[x][y]) return false;</span><br><span class="line">    if (grid[x][y] == 0) return false; //  0 表示不可通过</span><br><span class="line"></span><br><span class="line">    visited[x][y] = true;</span><br><span class="line"></span><br><span class="line">    if (x == n - 1 &amp;&amp; y == m - 1) &#123;</span><br><span class="line">        return true; // 假设目标点是右下角</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; 4; i++) &#123;</span><br><span class="line">        int nx = x + dx[i];</span><br><span class="line">        int ny = y + dy[i];</span><br><span class="line">        if (DFS(nx, ny, n, m, grid, visited)) return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    visited[x][y] = false;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>素数筛</title>
      <link href="/2025/04/12/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
      <url>/2025/04/12/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="埃拉托斯特尼筛法">埃拉托斯特尼筛法</h1><p><strong>算法原理</strong><br>初始化：<br>创建一个布尔数组 isPrime，长度为 n+1，并将所有元素初始化为 true。<br>数组的索引表示数字，值表示该数字是否为素数。<br>标记非素数：<br>从2开始，逐步标记所有素数的倍数为 false。<br>对于每个素数 p，从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>p</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">p^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span> 开始，以 p 为步长，将所有倍数标记为 false。<br>输出结果：<br>遍历数组，所有值为 true 的索引即为素数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; sieveOfEratosthenes(int n) &#123;</span><br><span class="line">    vector&lt;bool&gt; isPrime(n + 1, true); </span><br><span class="line">    vector&lt;int&gt; primes; // 用于存储素数</span><br><span class="line"></span><br><span class="line">    isPrime[0] = isPrime[1] = false;</span><br><span class="line"></span><br><span class="line">    for (int p = 2; p * p &lt;= n; p++) &#123;</span><br><span class="line">        if (isPrime[p]) &#123;</span><br><span class="line">            // 标记p的所有倍数为false</span><br><span class="line">            for (int i = p * p; i &lt;= n; i += p) &#123;</span><br><span class="line">                isPrime[i] = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 收集所有素数</span><br><span class="line">    for (int i = 2; i &lt;= n; i++) &#123;</span><br><span class="line">        if (isPrime[i]) &#123;</span><br><span class="line">            primes.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return primes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>软件设计</title>
      <link href="/2025/04/10/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/04/10/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="软件架构风格">软件架构风格</h1><p>软件架构风格是描述某一特定应用领域中系统组织方式的惯用模式，作为“可复用的组织模式和习语”，为设计人员的交流提供了公共的术语空间，促进了设计复用与代码复用。<br>架构风格的基本属性：设计元素的词汇表；配置规则；元素组合的语义解释以及使用某种风格构建的系统的相关分析<br>优势：</p><ul><li>可以极大地促进设计的重用性和代码的重用性，并且使得系统的组织结构易被理解。</li><li>使用标准的架构风格可较好地支持系统内部的互操作性以及针对特定风格的分析</li></ul><h2 id="数据流风格">数据流风格</h2><p>数据到达时激活，无数据时不工作</p><h3 id="批处理风格">批处理风格</h3><p>基本组件：独立的应用程序<br>连接件：某种类型的介质，完整的数据<br>特点：</p><ul><li>近乎线性</li><li>每个处理步骤都是一个独立的程序</li><li>每一步在前一步结束后才开始</li><li>数据必须是完整的，以整体的方式传播</li></ul><h3 id="管道-过滤器风格">管道-过滤器风格</h3><p>应用场景：数据源源不断地产生，系统需要对这些数据进行若干处理(分析、计算、转换等)。<br>基本组件：过滤器(功能模块)<br>连接件：管道(数据流)<br>过滤器的特点：<strong>独立性</strong></p><ul><li>过滤器独立完成自身功能，相互之间无需进行状态交互。</li><li>过滤器自身无状态</li><li>过滤器对其上下游的过滤器“无知”</li></ul><p>管道的特点：</p><ul><li>管道的作用：将数据从一个过滤器的输出口转移到<br>另一个过滤器的输入口</li><li>管道是单向流动的。</li><li>管道可以有缓冲区。</li></ul><p><strong>结果的正确性不依赖于各个过滤器运行的先后次序</strong><br>管道—过滤器风格优点：</p><ul><li>由于每个组件行为不受其他组件的影响，整个系统的行为易于理解。<strong>隐蔽性，高内聚低耦合</strong></li><li>管道-过滤器风格支持功能模块的复用。</li><li>基于管道-过滤器风格的系统具有较强的可维护性和可扩展性。</li><li>支持一些特定的分析，如吞吐量计算和死锁检测等。</li><li>管道-过滤器风格具有并发性</li></ul><p>缺点：</p><ul><li>管道-过滤器风格往往导致系统处理过程的成批操作。</li><li>根据实际设计的需要，设计者也需要对数据传输进行特定的处理（如为了防止数据泄漏而采取加密等手段，或者使用了底层公共命名），导致过滤器必须对输入、输出管道中的数据流进行解析或反解析，增加了过滤器具体实现的复杂性，系统性能不高。</li><li>交互式处理能力弱</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC.png" alt=""></p><h2 id="调用-返回风格">调用/返回风格</h2><h3 id="主程序-子程序风格">主程序/子程序风格</h3><p>该架构风格从功能的观点设计系统◦ 通过逐层分解和逐步细化得到系统架构，即将大系统分解为若干模块(模块化)，主程序调用这些模块实现完整的系统功能。主程序的正确性依赖于它所调用的子程序的正确性。<br>组件为主程序和子程序，连接件为调用-返回机制，拓扑结构为层次化结构。<br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E4%B8%BB%E7%A8%8B%E5%BA%8F%E5%AD%90%E7%A8%8B%E5%BA%8F%E9%A3%8E%E6%A0%BC.png" alt=""><br>优点：</p><ul><li>结构化程序设计的典型风格，相对于非结构化设计逻辑清晰，易理解。</li><li>开发过程采用逐步细化，将大系统分解为若干模块（模块化）。</li></ul><p>缺点：</p><ul><li>对数据存储格式的变化将会影响几乎所有的模块。</li><li>结构化程序在规模变大时会难理解、难测试、难维护。</li><li>这种分解方案难以支持有效的复用。随着程序规模的增大，大量函数、变量之间的关系错综复杂，要抽取可重用的代码往往变得十分困难。</li></ul><h3 id="面向对象风格">面向对象风格</h3><p>组件：管理器<br>连接件：过程调用<br>约束：去中心化，通常是单线程<br>优点：</p><ul><li>对象隐藏了其实现细节，所以可以在不影响其它对象的情况下改变对象的实现，不仅使得对象的使用变得简单、方便，而且具有很高的安全性和可靠性。</li><li>设计者可将一些数据存取操作的问题分解成一些交互的代理程序的集合。</li></ul><p>缺点：</p><ul><li>大量对象需要额外的结构化。当系统中有大量的对象时，需要额外的结构来组织这些对象，以便更好地管理和理解它们</li><li>管理大量交互。</li><li>行为的责任分布使系统难以理解。当行为的责任分布在多个对象和类之间时，系统的逻辑可能会变得复杂，难以理解和维护。例如，一个对象的行为可能依赖于多个其他对象的状态和行为。</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%A3%8E%E6%A0%BC.png" alt=""></p><h3 id="层次化风格">层次化风格</h3><p>基本思想：在分层系统（Layered System）中，系统被组织成若干个层次，每个层次由一系列组件组成；层次之间存在接口，通过接口形成call/return的关系——下层组件向上层组件提供服务，上层组件被看作是下层组件的客户端。<br>在分层架构中，组件被划分成几个水平层，每个层在应用中执行特定角色。<br>组件：通常是复合体；复合体通常是由一系列程序组成的<br>大多数分为四个标准层：表现层，业务层，持久层，数据库层<br>连接件：取决于组件的结构；经常在受限可见性下调用过程<br>约束：单线程<br>特点：</p><ul><li>分层架构中的每层为上一层提供服务，使用下一层的服务，只能见到与自己邻接的层。</li></ul><p>优点：</p><ul><li>支持基于可增加抽象层的设计，允许将一个复杂问题分解成一个增量步骤序列的实现。</li><li>支持扩展。每一层的改变最多只影响相邻层。</li><li>支持重用。只要给相邻层提供相同的接口，它允许系统中同一层的不同实现相互交换使用。</li></ul><p>缺点：</p><ul><li>不是所有系统都容易用这种模式来构建。</li><li>定义一个合适的抽象层次可能会非常困难，特别是对于标准化的层次模型。</li><li>层层相调，影响性能</li></ul><h3 id="客户机-服务器风格-c-s">客户机/服务器风格(C/S)</h3><p>客户机和服务器是两个相互独立的逻辑系统，为了完成特定的任务而形成一种协作关系。<br>客户机(前端，front-end)：业务逻辑、与服务器通讯的接口；<br>服务器(后端：back-end)：与客户机通讯的接口、业务逻辑、数据管理。</p><h4 id="两层c-s风格">两层C/S风格</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E5%B1%82CS%E6%9E%B6%E6%9E%84.png" alt=""><br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E4%B8%A4%E5%B1%82CS%E9%A3%8E%E6%A0%BC.png" alt=""><br>优点：</p><ul><li>客户机组件和服务器组件分别运行在不同的计算机上，有利于分布式数据的组织和处理。</li><li>组件之间的位置是相互透明的</li><li>客户机程序和服务器程序可运行在不同的操作系统上，便于实现异构环境和多种不同开发技术的融合。</li><li>软件环境和硬件环境的配置具有极大的灵活性，易于系统功能的扩展。</li><li>将大规模的业务逻辑分布到多个通过网络连接的低成本的计算机上，降低了系统的整体开销。</li></ul><p>缺点：</p><ul><li>开发成本较高（客户机的软硬件要求高）。</li><li>客户机程序的设计复杂度大，客户机负荷重。</li><li>信息内容和形式单一。</li><li>C/S架构升级需要开发人员到现场更新客户机程序，对运行环境进行重新配置，增加了维护费用。</li><li>两层C/S结构采用了单一的服务器，同时以局域网为中心，难以扩展到Internet。</li><li>数据安全性不高，客户端程序可以直接访问数据库服务器。</li></ul><h4 id="三层c-s风格">三层C/S风格</h4><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E4%B8%89%E5%B1%82CS%E6%9E%B6%E6%9E%84.png" alt=""><br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E4%B8%89%E5%B1%82CS%E9%A3%8E%E6%A0%BC.png" alt=""><br>相比两层C/S的优点：</p><ul><li>合理地划分三层结构的功能，可以使系统的逻辑结构更加清晰，提高软件的可维护性和可扩充性。</li><li>在实现三层C/S架构时，可以更有效地选择运行平台和硬件环境，从而使每一层都具有清晰的逻辑结构、良好的负荷处理能力和较好的开放性。</li><li>在C/S架构中，可以分别选择合适的编程语言并行开发。</li><li>系统具有较高的安全性。</li></ul><p>但使用时需要注意2个问题：</p><ul><li>如果各层之间的通信效率不高，即使每一层的硬件配置都很高，系统的整体性能也不会太高。</li><li>必须慎重考虑三层之间的通信方法、通信频率和传输数据量，这和提高各层的独立性一样也是实现三层C/S架构的关键性问题。</li></ul><h4 id="浏览器-服务器风格-b-s">浏览器/服务器风格(B/S)</h4><p>与三层C/S结构的解决方案相比，B/S架构在客户机上采用了WWW浏览器，将Web服务器作为应用服务器。<br>B/S架构核心是Web服务器，数据请求、网页生成、数据库访问和应用程序执行全部由Web服务器来完成。<br>在B/S架构中，系统安装、修改和维护全在服务器端解决，客户端无任何业务逻辑。<br>优点：</p><ul><li>客户端只需要安装浏览器，操作简单，能够发布动态信息和静态信息。</li><li>运用HTTP标准协议和统一客户端软件，能够实现跨平台通信。</li><li>开发成本比较低，只需要维护Web服务器程序和中心数据库。客户端升级可以通过升级浏览器来实现。</li></ul><p>缺点：</p><ul><li>个性化程度比较低，所有客户端程序的功能都是一样的。</li><li>客户端数据处理能力比较差，加重了Web服务器的工作负担，影响系统的整体性能。</li><li>在B/S架构中，数据提交一般以页面为单位，动态交互性不强，不利于在线事物处理</li><li>B/S架构的可扩展性比较差，系统安全性难以保障。</li><li>B/S架构的应用系统查询中心数据库，其速度要远低于C/S架构。</li></ul><h2 id="以数据为中心的风格">以数据为中心的风格</h2><p>最初，硬件/软件系统的配置信息均被各自保存在一个配置文件中(.ini)；这些文件散落在系统各个角落，很难对其进行维护；引入注册表的思想，将所有.ini文件集中起来，形成共享仓库，为系统运行起到了集中的资源配置管理和控制调度的作用。<br>注册表中保存了系统的所有硬件和软件配置信息；这些信息影响或控制系统/应用软件的行为，应用软件安装/运行/卸载时对其进行添加/修改/删除信息，以达到改变系统功能和控制软件运行的目的。</p><h3 id="仓库风格">仓库风格</h3><p>基本思想：仓库是存储和维护数据的中心场所<br>组件：</p><ul><li>中心数据结构组件，表示当前数据的状态</li><li>相对独立的组件集合，各个功能模块等</li></ul><p>连接件：数据仓库与独立组件之间的交互<br>优点：</p><ul><li>便于模块间的数据共享</li><li>方便模块的添加、更新和删除</li><li>避免了知识源的不必要的重复存储</li></ul><p>缺点：</p><ul><li>对于各个模块，需要一定的同步/加锁机制保证数据结构的完整性和一致性</li></ul><h3 id="黑板系统风格">黑板系统风格</h3><p>一个大问题被分解为若干个子问题，每个子问题的解决需要不同的问题表达方式和求解模型，分别设计求解程序<br>组件：黑板，知识源，控制组件<br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E9%BB%91%E6%9D%BF%E7%B3%BB%E7%BB%9F%E9%A3%8E%E6%A0%BC.png" alt=""><br>知识源：</p><ul><li>知识源是描述某个独立领域问题的知识及其处理方法的知识库</li><li>知识源分别存放且相互独立</li><li>他们通过黑板进行通讯 ，合作求出问题的解</li><li>通常知识源具有“ 条件- 动作”的形式 。当条件满足时 ，知识源被触发 ，其动作部分增加或修改黑板上的内容。</li></ul><p>控制器：</p><ul><li>时刻监视黑板状态变化</li><li>对黑板上信息的当前状态进行判断和评价</li><li>当黑板的状态满足了知识源的执行条件时，该知识源被控制器触发并进行计算，然后将结果更新到黑板上</li><li>这种更新又导致其他知识源参与计算并更新黑板，直到找到问题解为止</li></ul><p>优点：</p><ul><li>便于多客户共享大量数据，他们不关心数据何时有的、谁提供的、怎样提供的。</li><li>既便于添加新的作为知识源代理的应用程序，也便于扩展共享的黑板数据结构。</li><li>知识源可重用。</li><li>支持容错性和健壮性。</li></ul><p>缺点：</p><ul><li>不同的知识源代理对于共享数据结构要达成一致，而且，这也造成对黑板数据结构的修改较为困难——要考虑到各个代理的调用。</li><li>需要一定的同步/加锁机制保证数据结构的完整性和一致性，增大了系统复杂度。</li></ul><h2 id="虚拟机风格">虚拟机风格</h2><p>虚拟机是一种软件，创建了一种虚拟的环境，将用户和底层平台隔离开来。<br>JVM(Java Virtual Machine)可适应所有的硬件与OS平台，从而使得Java具有“一次书写，到处运行”的能力。<br>在JVM上运行的程序必须首先被编译为标准的二进制格式的文件：.class<br>Java class文件并不是机器代码或目标代码，而是一种具有标准中间格式的二进制文件，无法直接在任何OS平台上执行；Java class必须在JVM的支持下才能真正执行</p><h3 id="解释器风格">解释器风格</h3><p>基本思想：解释器是一个用来执行其他程序的程序，它针对不同的硬件平台实现了一个虚拟机，将高抽象层次的程序翻译为低抽象层次所能理解的指令，以弥合程序语义所期望的与硬件提供的计算引擎之间的差距。<br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%A7%A3%E9%87%8A%E5%99%A8%E9%A3%8E%E6%A0%BC.png" alt=""><br>优点：</p><ul><li>它有利于实现程序的可移植性和语言的跨平台能力；</li><li>可以对未来的硬件进行模拟和仿真，能够降低测试所带来的复杂性和昂贵花费</li></ul><p>缺点：</p><ul><li>额外的间接层次导致了系统性能的下降</li></ul><p><strong>编译器不会执行输入的源程序代码，而是将其翻译为另一种语言，通常是可执行的机器码或目标码，并输出到文件中以便随后链接为可执行文件并加以执行</strong><br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E7%BC%96%E8%AF%91%E5%99%A8.png" alt=""><br><strong>在解释器中，程序源代码被解释器直接加以执行</strong><br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E8%A7%A3%E9%87%8A%E5%99%A8.png" alt=""><br>两者的区别：</p><ul><li>解释器的执行速度要慢于编译器产生的目标代码的执行速度，但是却低于编译器“编译+链接+执行”的总时间</li><li>解析器执行速度之所以慢，是因为每次解释执行的时候，都需要分析程序的结构，而编译代码则直接执行而无需重复编译</li><li>解释器对内存的分配是在解释时才进行的；而编译器则是在编译时就规划好了变量的内存使用方案，因此运行时直接将程序代码装入内存并执行即可</li></ul><p>解释器有三种策略，分别是传统解释器，基于字节码的解释器和JIT编译器<br>传统解释器是直接读取源代码并加以执行。<br>字节码解释器是首先将源代码“编译”为高度压缩和优化的字节码，但并不是真正的机器目标代码，因而与硬件平台无关；编译后得到的字节码然后被解释器加以解释<br>实时编译器(JIT)，字节码在运行时被编译为本机的目标代码。第一步编译得到字节码，然后，字节码被配置到目标系统中，当字节码被执行时，运行环境下的编译器将其翻译为本地机器码</p><h3 id="基于规则的系统风格">基于规则的系统风格</h3><p>任何规则都包含两部分：</p><ul><li>IF部分：规则的前提或条件</li><li>THEN部分：规则的结论或触发的行为</li></ul><p>一个规则可以有多个条件，使用AND或OR连接<br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E5%9F%BA%E4%BA%8E%E8%A7%84%E5%88%99%E7%9A%84%E7%B3%BB%E7%BB%9F%E9%A3%8E%E6%A0%BC.png" alt=""><br>优点：</p><ul><li>降低了修改业务逻辑的成本</li><li>缩短了开发时间</li><li>将规则外部化，可在多个应用之间共享</li><li>对规则的改变将非常迅速并且具有较低的风险</li></ul><h2 id="独立组件风格">独立组件风格</h2><p>独立构件风格的软件系统由多个独立的组件构成，这些组件之间不共享状态，通过网络、消息队列或者其他形式的消息传递机制来进行通信和数据交换。<br>独立性：</p><ul><li>组件拥有自己的内部状态和行为，组件间松耦合。</li><li>组件可以单独测试，单独部署。</li><li>组件可在不同的物理节点或进程中运行。</li></ul><p>组件：</p><ul><li>功能独立</li><li>为每个组件定义清晰的接口,包括输入、输出和预期行为。</li></ul><p>连接件：</p><ul><li>消息传递、事件驱动或远程过程调用(RPC)。</li><li>可使用中间件技术(如消息队列)来协调组件间的交互。</li></ul><p>约束：</p><ul><li>系统执行的过程依赖于被触发事件的上下文约束。</li></ul><p>进程通讯：组件作为独立进程运行，通过显式通信协议直接交换数据。消息传递的方式可以是点到点、异步或同步方式及远程过程调用等。<br>事件驱动：组件通过发布/订阅事件隐式交互，发送者不依赖接收者的存在或响应。</p><h3 id="进程通讯风格">进程通讯风格</h3><p>进程通讯特点：</p><ul><li>同步/异步通信</li><li>点对点交互：组件需明确知道通信对象</li><li>典型技术：REST API、gRPC、RabbitMQ</li></ul><p>进程通讯应用场景：微服务架构、分布式计算</p><h3 id="事件驱动风格">事件驱动风格</h3><p>消息：</p><ul><li>计算机中，消息是具有特定含义的数据</li><li>对象通过发送消息的方式请求另一个对象为其服务</li></ul><p>事件：</p><ul><li>能够激活对象功能的动作。当发生这种动作后将给所涉及对象发送一个消息，对象便可执行相应的功能</li></ul><p>通常，在一个系统中，组件接口提供了访问过程或函数的端口的集合，组件通过显式地调用这些过程或函数来与其他组件交互。然而，一种基于隐式调用(implicit invocation)的集成技术非常受关注，该技术就是事件驱动(Event-based) 的软件架构风格。<br>基本思想：</p><ul><li>组件不直接调用一个过程，而是发布或广播一个或多个事件。</li><li>系统中的其它组件通过注册与一个事件关联起来的过程，来表示对某一个事件感兴趣。当这个事件发生时，系统本身会调用所有注册了这个事件的过程。这样一个事件的激发会导致其它模块中过程的隐式调用。</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E9%A3%8E%E6%A0%BC.png" alt=""><br>特点：事件的触发者并不知道哪些构件会被这些事件影响，相互保持独立。<br>事件调度策略：<br>事件分派模块的功能：负责接收到来的事件并派遣它们到其它模块</p><ul><li>广播式：派遣模块将事件广播到所有的模块，但只有感兴趣的模块才去取事件并触发自身的行为。</li><li>选择广播式：派遣模块将事件送到那些已经注册了的模块中。</li></ul><p>事件驱动编程的一般步骤：<br>1 确定响应事件的元素；<br>2 为指定元素确定需要响应的事件类型；<br>3 为该元素的相应事件编写事件处理程序；<br>4 将事件处理程序绑定到指定元素的指定事件。<br>优点：</p><ul><li>事件声明者不需要知道哪些组件会影响事件，组件之间关联较弱。一个组件出错将不会影响其他构件。</li><li>提高软件复用能力。只要在系统事件中注册组件的过程，就可以将该组件集成到系统中。</li><li>系统便于升级。只要组件名和事件中所注册的过程名保持不变，原有组件就可以被新组件替代。</li></ul><p>缺点：</p><ul><li>组件放弃了对计算的控制权，完全由系统来决定。</li><li>存在数据交换问题。</li><li>该风格中，正确性验证成为一个问题。</li></ul><h2 id="其他软件架构风格">其他软件架构风格</h2><h3 id="c2风格">C2风格</h3><p>C2风格的主要思想来源于Chiron-1用户界面系统，因此又被命名为Chiron-2，简称C2。<br>C2架构风格可以概括为：通过连接件绑定在一起的按照一组规则运作的并行组件网络。该规则规定了所有组件之间的交互必须通过异步消息机制来实现<br>C2是一种基于组件和消息的架构风格，适用于GUI软件开发，构建灵活和可扩展的应用系统。<br>C2风格的系统组织规则：</p><ul><li>组件之间不能直接连接</li><li>组件和连接件都有一个顶部和一个底部</li><li>组件的顶部应连接到某连接件的底部，组件的底部则应连接到某连接件的顶部</li><li>一个连接件可以和任意数目的其他组件和连接件连接</li><li>当两个连接件进行直接连接时，必须由其中一个的底部到另一个的顶部</li></ul><p>C2构件的内部，通信和处理是分开完成的<br>C2连接件：</p><ul><li>连接件负责把构件绑定在一起，其上可以连接任何数量的构件和连接件</li><li>连接件的主要职责：<ul><li>消息的路由和广播</li><li>消息的过滤</li></ul></li></ul><p>优点：</p><ul><li>可使用任何编程语言开发组件，组件重用和替换易实现</li><li>由于组件之间相对独立，依赖性小，因而该风格具有一定扩展能力，可支持不同粒度的组件</li><li>组件不需共享地址空间</li><li>可实现多个用户和多个系统之间的交互</li><li>可实现多个工具集和多种媒体类型，动态更新系统框架结构</li></ul><p>缺点：</p><ul><li>不太适合大规模流式风格系统，以及对数据库使用比较频繁的使用</li></ul><h3 id="平台-插件风格">平台/插件风格</h3><p>插件是一种遵循统一的预定义接口规约编写出来的程序，应用程序在运行时通过接口规约对插件进行调用，以扩展应用程序的功能。<br>插件的本质在于不修改程序主体(或者程序运行平台)的情况下对软件功能进行扩展与加强。<br>这意味着软件开发者可以通过公布插件的预定义接口规约，从而允许第三方的软件开发者通过开发插件对软件的功能进行扩展，而无须对整个程序代码进行重新编译。<br>“平台/插件”软件结构将待开发的目标软件分为两部分：</p><ul><li>程序的主体或主框架，可定义为平台</li><li>功能扩展或补充模块，可定义为插件</li></ul><p>平台所完成的功能应为一个软件系统的核心和基础，可以把平台基本功能分为两个部分：</p><ul><li>内核功能：是整个软件的重要功能，一个软件的大部分功能应由内核功能完成。</li><li>插件处理功能：用于扩展平台和管理插件，为插件操纵平台和与插件通信提供标准平台扩展接口。</li></ul><p>插件受到的约束：</p><ul><li>插件必须能在运行过程中动态地插入平台和从平台中注销，且不影响系统的运行。</li><li>当在系统中插入插件后，系统的功能得到扩展或升级。</li><li>多个插件之间、插件和平台之间不会发生冲突。</li></ul><p>实现该风格需要定义两个标准接口：</p><ul><li>平台扩展接口：完全由平台实现，插件只是调用和使用</li><li>插件接口：完全由插件实现，平台也只是调用和使用。</li></ul><p>优点：</p><ul><li>降低系统各模块之间的互依赖性</li><li>系统模块独立开发、部署、维护</li><li>根据需求动态的组装、分离系统</li></ul><p>缺点：</p><ul><li>插件是别人开发的可以用到某主程序中的，只服务于该主程序，可重用性差</li></ul><h3 id="面向agent风格">面向Agent风格</h3><p>Agent组件：能够自主运行、具有某种程度的智能以适应环境变化、可以与其他Agent进行交互和通信，并且通常具备一定的目标追求能力。<br>Agent组件有别于以往任何系统的组件类型，其所具有的自主性、智能性、交互性等特性是传统架构对象所不具备的。<br>这些Agent可以是物理实体（例如机器人）或软件实体（例如在计算机网络上执行特定任务的程序）。它们通过感知周围环境，采取行动来影响该环境，并基于自身的目标和知识做出决策。<br>Agent连接件：对复合型组件的连接，该连接能够提供通信、协调、转换、接通等服务<br>多Agent系统中的连接件并非显示地将两个不同的组件联系起来。不同Agent之间的联系是根据运行时状态来决定的。<br>优点：</p><ul><li>面向Agent的软件工程方法对于解决复杂问题是一种好的技术, 特别是对于分布开放异构的软件环境</li></ul><p>缺点：</p><ul><li>通信开销大，多Agent频繁交互可能导致延迟。</li><li>为了适应动态环境，应对复杂场景，Agent的设计比较复杂。</li></ul><p>适用于需要处理高度动态和不确定性环境的应用场景，如自动化、电子商务、信息管理、分布式控制系统等。</p><h3 id="面向方面软件架构风格">面向方面软件架构风格</h3><p>面向方面的编程(AOP：Aspect Oriented Programming)<br>系统的有些特性和需求是横切于系统的每一个层面中，并融于系统的每一个组件中，这种特性称为系统的方面(Aspect)需求特性或关注点<br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/AOP.png" alt=""><br>应用AOP的主要目的----尽量分离“技术问题实现”和“业务问题实现”：</p><ul><li><p>它允许开发者能够对横切关注点进行模块化设计。</p></li><li><p>能够实现分散关注，将通用需求功能从不相关类之中分离出来。</p></li><li><p>能够实现代码重用。</p></li><li><p>方面（Aspect）：方面是横切关注点的模块化单元。一个方面可以包含与特定行为相关的建议（advice）、连接点（join points）以及切入点（pointcuts）。</p></li><li><p>建议（Advice）：指的是方面应该执行的具体动作。这可以是在特定事件发生之前（前置建议）、之后（后置建议），或者当异常抛出时执行的动作。</p></li><li><p>连接点（Join Point）：程序执行过程中的某些点，如方法调用、异常抛出等，在这些点上可以插入建议。</p></li><li><p>切入点（Pointcut）：一组连接点的集合，定义了在哪些建议应该被执行的连接点上应用。</p></li><li><p>织入（Weaving）：将方面代码整合到主程序逻辑的过程。织入可以在编译期、加载期或运行时完成。</p></li></ul><p>优点：</p><ul><li>增强功能独立性：通过分离横切关注点，使得系统更加功能独立，每个模块只需专注于其核心职责。</li><li>减少代码重复：避免了为实现相同的横切功能而在多个地方编写类似的代码。</li><li>提高可维护性：由于横切关注点被集中处理，因此更容易进行更新和维护。</li><li>简化设计：让开发者能够更清晰地表达系统的结构和行为。</li></ul><p>缺点：</p><ul><li>有一定学习成本</li><li>因为建议（Advice）可以改变程序流而不需要直接修改源代码，所以可能会增加调试难度。</li><li>存在潜在的性能开销，特别是在运行时织入方面时，可能会引入额外的性能成本</li></ul><h3 id="面向服务架构风格">面向服务架构风格</h3><p>SOA 是一个组件模型，它将应用程序的不同功能单元（服务）通过这些服务之间定义良好的接口和契约联系起来。<br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/SOA.png" alt=""></p><ul><li>服务请求者：可以是服务或者第三方的用户，通过查询服务提供者在服务注册中心发布的服务接口的描述，通过服务接口描述来通过RPC或者SOAP进行绑定调用服务提供者所提供的业务或服务。</li><li>服务提供者：作为服务管理者和创建者，必须将服务描述的接口发布到服务注册中心才能被潜在的服务请求发现，能够为合适的服务请求者提供服务 。</li><li>服务注册中心：相当于服务接口的管理中心，服务请求者者能够通过查询服务注册中心的数据库来找到需要的服务调用方式和接口描述信息。</li><li>发布：为了便于服务请求者发现，服务提供者将对服务接口的描述信息发布到服务注册中心上。</li><li>发现：服务请求者通过查询服务注册中心的数据库来找到需要的服务，服务注册中心能够通过服务的描述对服务进行分类，使服务提供者更快定位所需要的服务范围。</li><li>绑定和调用：服务请求者在查询到所需要服务描述信息，根据这些信息服务请求者能够调用服务。</li></ul><p>优点：</p><ul><li>灵活性，根据需求变化，重新编排服务。</li><li>对IT资产的复用。</li><li>使企业的信息化建设真正以业务为核心。业务人员根据需求编排服务，而不必考虑技术细节。</li></ul><p>缺点：</p><ul><li>服务的划分很困难。</li><li>服务的编排是否得当。</li><li>如果选择的接口标准有问题，如主流的Web service之类，会带来系统的额外开销和不稳定性。</li><li>对IT硬件资产还谈不上复用。</li><li>目前主流实现方式接口很多，很难统一。</li><li>目前主流实现方式只局限于不带界面的服务的共享。</li></ul><h3 id="微服务架构">微服务架构</h3><p>特点：</p><ul><li>服务自治<ul><li>微服务围绕具体业务能力组织系统，高度内聚：</li><li>每个服务独立开发、部署、扩展，技术栈可异构(如Java、Python、Go)</li><li>各服务拥有专属数据存储</li></ul></li><li>轻量级通信机制<ul><li>同步通信：HTTP/REST、gRPC。</li><li>异步通信：消息队列（如Kafka、RabbitMQ）</li></ul></li><li>去中心化治理：<ul><li>服务独立演进，允许团队自治。</li><li>基础设施通过统一平台管理。</li></ul></li><li>容错和弹性设计<ul><li>通过熔断（Hystrix）、重试、降级等机制保障系统可用性和稳定性。</li></ul></li></ul><p>优点：</p><ul><li>加速开发周期：团队可以并行工作于不同的服务上，加快了新功能的发布速度。</li><li>技术多样性：可以根据每个服务的需求选择最适合的技术栈。</li><li>弹性扩展：可以针对具体的服务进行扩展，而不需要扩展整个应用。</li><li>容错，易维护：单个服务宕机不会导致系统崩溃，且由于服务小并单一职责，更容易理解和维护。</li></ul><p>缺点：</p><ul><li>分布式系统的复杂性</li><li>运维成本高</li><li>团队协作需要严格规范接口定义</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/SOA%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1.png" alt=""></p><h3 id="基于层次消息总线的架构风格-jb-hmb风格">基于层次消息总线的架构风格(JB/HMB风格)</h3><p>JB/HMB风格基于层次消息总线、支持组件的分布和并发，组件之间通过消息总线进行通讯。<br>消息总线是系统的连接件，负责消息的分派、传递和过滤以及处理结果的返回。各个组件挂接在消息总线上，向总线登记感兴趣的消息类型。不要求各个构件具有相同的地址空间或局限在同台机器上，可较好地描述分布式并发系统。<br>优点：</p><ul><li>模块化与可维护性</li><li>灵活、可扩展</li><li>支持异步通信</li><li>增强了系统的容错能力</li></ul><p>缺点：</p><ul><li>消息总线本身比较复杂</li><li>调试和问题定位复杂</li><li>性能开销大</li><li>如何保证消息传递的一致性和可靠性</li></ul><h3 id="正交架构风格">正交架构风格</h3><p>正交软件架构(Orthogonal Software Architecture) 由组织层(Layer)和线索(Thread)的组件(Component)构成。<br>其基本思想是把应用系统的结构按功能的正交相关性，垂直分割为若干个线索(子系统)，线索又分为几个层次，每个线索由多个具有不同层次功能和不同抽象级别的组件构成。<br>特点：</p><ul><li>由完成不同功能的n(n&gt;1)个线索(子系统)组成；</li><li>系统具有m(m &gt;1)个不同抽象级别的层；</li><li>线索之间是相互独立的(正交的)；</li><li>系统有一个公共驱动层(一般为最高层)和公共数据结构(一般为最低层)。</li></ul><p>优点：</p><ul><li>结构清晰，易于理解。</li><li>易修改，可维护性强。</li><li>可移植性强，重用粒度大。</li></ul><p>缺点：</p><ul><li>在实际应用中，并不是所有软件系统都能完全正交化，或者有时完全正交化的成本太高。因此，在进行应用项目的软件架构设计时，必须反复权衡进一步正交化的额外开销与所得到的更好的性能之间的关系。</li></ul><h3 id="异构风格">异构风格</h3><p>异构架构是几种风格的组合。<br>优点：</p><ul><li>选择异构架构风格，可以实现遗留代码的重用。</li><li>在某一单位中，规定了共享软件包和某些标准，但仍会存在解释和表示习惯上的不同。选择异构架构风格，可以解决这一问题。</li></ul><p>缺点：</p><ul><li>不同风格之间的兼容问题有时很难解决</li></ul><h3 id="模型-视图-控制器风格-mvc">模型-视图-控制器风格(MVC)</h3><p>MVC结构主要包括模型、视图和控制器三部分:</p><ul><li>模型：模型是应用程序的核心，它封装了问题的核心数据、逻辑关系和计算功能，提供了处理问题的操作过程。</li><li>视图：视图是模型的表示，提供了交互界面，为用户显示模型信息。</li><li>控制器：控制器负责处理用户与系统之间的交互，为用户提供操作系统。</li></ul><p>优点：</p><ul><li>多个视图与一个模型相对应。变化——传播机制确保了所有相关视图都能够及时地获取模型变化信息，从而使所有视图和控制器同步，便于维护。</li><li>具有良好的移植性。由于模型独立于视图，因此可以方便的实现不同部分的移植。</li><li>系统被分割为三个独立的部分，当功能发生变化时，改变其中的一个部分就能满足要求。</li></ul><p>缺点：</p><ul><li>增加了系统设计和运行复杂性。</li><li>视图与控制器连接过于紧密，妨碍了二者的独立重用。</li><li>视图访问模型的效率比较低。由于模型具有不同的操作接口，因此视图需要多次访问模型才能获得足够的数据。</li><li>频繁访问未变化的数据，也将降低系统的性能。</li></ul><h1 id="软件架构与敏捷开发">软件架构与敏捷开发</h1><p>敏捷开发的基本理念：</p><ul><li>强调个体和互动比强调过程和工具更好</li><li>强调获得可运行的软件比强调完成详尽的文档好</li><li>强调与客户合作比强调进行详细的合同谈判好</li><li>强调变化比强调遵循既定的计划好</li></ul><p>敏捷开发在实践中表现为一种迭代、增量和持续集成的开发方法。</p><ul><li>迭代反映了项目的开发节奏，是一个多周期的开发过程。</li><li>增量说明了项目的实际进展，整个项目就是由很多增量构成的。</li><li>持续集成反映了集成增量的过程是持续进行的。</li></ul><p>软件架构与敏捷开发都是一个权衡的过程：软件架构设计需要权衡涉众们的各种需求，在众多的解决方案中确定唯一的架构设计方案，从而保证软件开发的有效性。敏捷开发是在软件开发过程混沌和大量开发管理活动加入的两个极端中做出的一种权衡。<br>软件架构与敏捷开发目的都是<strong>为了提高软件开发效率、提高软件质量、降低软件成本，将开发团队的价值最大化</strong>。<br>在敏捷开发的支持者看来，传统的软件架构设计与敏捷思想相违，因为过多的预先设计使得软件开发过程在面对变化时缺乏灵活性，其管理成本极有可能由于后续的重构而成为无用功。但是根据学术界与企业界的研究和调查，发现软件架构设计对于敏捷开发来说也是必要的。两者在软件开发实践中能够共同存在，且互相促进。<br>敏捷开发非常重视软件的架构设计，但是轻架构的详细设计。</p><ul><li>敏捷思想中将传统的架构设计分成：种子架构设计+详细架构设计。</li><li>种子架构设计关注软件系统的骨架或轮廓的设计。</li><li>敏捷开发将详细架构设计转移到Code编码阶段、重构阶段、单元测试阶段等。</li><li>分离后，敏捷软件种子架构的内容包括：软件的架构层次，重要模块、重要类的说明（无须设计全部的类和方法）等。</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B.png" alt=""><br>敏捷开发把传统软件开发前期的详细架构设计，分散到了整个敏捷开发软件过程中，以达到<strong>提高效率、减少风险</strong>的目的。<br><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png" alt=""><br>需求分析：</p><ul><li>敏捷开发中的需求分析引入了架构设计的理念，分为<strong>初始阶段需求分析</strong>和<strong>迭代阶段需求分析</strong>。</li><li>初始阶段的需求分析中摒弃了具体的细节，仅仅抓住<strong>软件最高层的概念</strong>。</li><li>迭代阶段需求分析是随着项目的进展逐步完善的，具有<strong>高适应性</strong>。</li></ul><p>初始设计：</p><ul><li>初始阶段的目标是在所有涉众之间达成关于项目的生命周期目标的协议，在项目进行之前<strong>确定重要的业务和需求风险</strong>。</li><li>初始设计需要对软件系统的设计进行<strong>全局抽象层次</strong>上的考虑。</li><li>包括<strong>系统的基本处理流程、系统的组织结构、模块划分、功能分配</strong>等</li></ul><p>迭代过程：</p><ul><li>针对需求的不可预见性，在敏捷开发中使用了迭代过程。</li><li>长期的计划通常是不稳定的，单次迭代的短期计划是稳定的。</li><li>迭代开发都是基于上次迭代的结果，每次迭代都有一个坚实的基础。</li><li><strong>迭代设计</strong>：是根据当前迭代过程需要完成的工作任务来进行需求分析、设计和编码等。</li><li><strong>重构</strong>：迭代过程中的重构往往发生在编码阶段，重构是对软件架构的持续改进。</li><li><strong>确定架构</strong>：迭代过程中生产出的软件（*(或组件)经过测试后确实能达到预期的要求，生产出了可交付的软件产品。</li><li><strong>客户交流</strong>：根据交付的可用软件，与客户进行充分交流。通过客户反馈的信息，快速有效地适应变化，在后续的迭代过程中完成客户的新要求。</li></ul><p>敏捷的思想在软件架构设计中最主要的体现就是<strong>团队设计</strong>和<strong>简单设计</strong>这两种设计理念。</p><ul><li>团队设计<ul><li>团队设计的理论依据是群体决策，这样可以避免理论上完美，但程序员无法实现的架构设计。</li><li>方式：<ul><li>全体人员参与架构设计</li><li>组织优秀的开发人员组成设计组</li></ul></li><li>这样设计出来的架构称为<strong>原始架构</strong>，在后续的迭代过程中不断地反馈和改进。</li><li>优点：<ul><li>其结论要比个人决策更加完整，避免个人遗漏，相对稳定、周密。</li></ul></li><li>缺点：<ul><li>需要额外付出沟通成本、决策效率低、责任不明确等。</li></ul></li></ul></li><li>简单设计<ul><li>敏捷的思想要求软件架构设计必须是简单设计。</li><li>这里的简单体现在两个方面：表达方式的简单化和现实抽象的简单化。<ul><li>表达方式的简单化：指的是敏捷开发中对详细架构描述文档等中间产物的弱化，只满足有效沟通即可。</li><li>现实抽象的简单化：指的是仅针对当前需求建模分析，不做“多余的”工作。</li></ul></li><li>简单设计可以降低开发成本、提升沟通效率、增强适应性和稳定性。</li></ul></li></ul><p>优秀的敏捷软件架构的设计过程一般同时包含<strong>规划式设计</strong>和<strong>演进式设计</strong>，具体体现为<strong>初始阶段设计</strong>和<strong>迭代过程中的设计</strong>。<br>各种敏捷开发方法在实际应用中基本上都会在正式编码前有一个初步的设计。不同方法的初始阶段设计大同小异,都是为了得到一个原始架构，但输出不同：</p><ul><li>XP初始阶段输出的原始架构是以系统隐喻的方式存在的。</li><li>Scrum初始阶段输出的原始架构是以产品功能列表的方式存在的。</li><li>FDD(特征驱动的软件开发)初始阶段输出的原始架构是一个特征表。</li></ul><p><img src="/img/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/XP.png" alt=""></p><blockquote><p>XP中的迭代过程</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高精度</title>
      <link href="/2025/04/09/%E9%AB%98%E7%B2%BE%E5%BA%A6/"/>
      <url>/2025/04/09/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是高精度运算">什么是高精度运算</h1><p>高精度运算用于处理超出标准整数类型范围的数值。C++中的 int 和 long long 类型分别能处理的最大值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>63</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{63}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，但对于更大的数值，就需要使用高精度运算。<br>高精度运算的核心思想是将大数分解为多个较小的数字（通常用字符串或数组存储），然后逐位进行运算。</p><h1 id="高精度加法">高精度加法</h1><p><strong>原理</strong><br>-将两个大数从最低位到最高位逐位相加。<br>-如果某一位相加的结果大于等于10，则向高位进位。<br>-最终结果可能比原数多一位。<br>代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">string highPrecisionAdd(const string&amp; a, const string&amp; b) &#123;</span><br><span class="line">    string result;</span><br><span class="line">    int carry = 0; // 进位</span><br><span class="line">    int i = a.size() - 1, j = b.size() - 1;</span><br><span class="line"></span><br><span class="line">    // 从后向前逐位相加</span><br><span class="line">    while (i &gt;= 0 || j &gt;= 0 || carry &gt; 0) &#123;</span><br><span class="line">        int num1 = (i &gt;= 0) ? a[i] - &#x27;0&#x27; : 0; // 当前位的数字</span><br><span class="line">        int num2 = (j &gt;= 0) ? b[j] - &#x27;0&#x27; : 0;</span><br><span class="line"></span><br><span class="line">        int sum = num1 + num2 + carry; // 当前位的和</span><br><span class="line">        result.push_back((sum % 10) + &#x27;0&#x27;); // 将结果存储为字符</span><br><span class="line">        carry = sum / 10; // 更新进位</span><br><span class="line">        i--; // 向前移动</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为结果是反向存储的，需要反转</span><br><span class="line">    reverse(result.begin(), result.end());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度减法">高精度减法</h1><p><strong>原理</strong></p><ul><li>确保被减数大于或等于减数，否则结果为负数。</li><li>从最低位到最高位逐位相减。</li><li>如果某一位不够减，则从高位借1（即加10）。<br>代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">string highPrecisionSubtract(const string&amp; a, const string&amp; b) &#123;</span><br><span class="line">    if (a.size() &lt; b.size() || (a.size() == b.size() &amp;&amp; a &lt; b)) &#123;</span><br><span class="line">        string result = highPrecisionSubtract(b, a);</span><br><span class="line">        return &quot;-&quot; + result; // 添加负号</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string result;</span><br><span class="line">    int carry = 0; // 借位</span><br><span class="line">    int i = a.size() - 1, j = b.size() - 1;</span><br><span class="line"></span><br><span class="line">    // 从后向前逐位相减</span><br><span class="line">    while (i &gt;= 0 || j &gt;= 0) &#123;</span><br><span class="line">        int num1 = i &gt;= 0 ? a[i] - &#x27;0&#x27; : 0; // 当前位的数字</span><br><span class="line">        int num2 = j &gt;= 0 ? b[j] - &#x27;0&#x27; : 0;</span><br><span class="line"></span><br><span class="line">        int diff = num1 - carry - num2; // 当前位的差值</span><br><span class="line">        if (diff &lt; 0) &#123;</span><br><span class="line">            diff += 10; // 借位</span><br><span class="line">            carry = 1; // 设置借位</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            carry = 0; // 清除借位</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.push_back(diff + &#x27;0&#x27;); // 将结果存储为字符</span><br><span class="line">        i--; // 向前移动</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 去掉前导0</span><br><span class="line">    while (result.size() &gt; 1 &amp;&amp; result.back() == &#x27;0&#x27;) &#123;</span><br><span class="line">        result.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 因为结果是反向存储的，需要反转</span><br><span class="line">    reverse(result.begin(), result.end());</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度乘法">高精度乘法</h1><p><strong>原理</strong></p><ul><li>将两个大数从最低位到最高位逐位相乘。</li><li>每次相乘的结果需要加上之前的结果，并注意进位。</li><li>最终结果可能比原数多几位。<br>代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string highPrecisionMultiply(const string&amp; a, const string&amp; b) &#123;</span><br><span class="line">    int lenA = a.size(), lenB = b.size();</span><br><span class="line">    vector&lt;int&gt; result(lenA + lenB, 0); // 结果数组</span><br><span class="line"></span><br><span class="line">    // 从后向前逐位相乘</span><br><span class="line">    for (int i = lenA - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        for (int j = lenB - 1; j &gt;= 0; j--) &#123;</span><br><span class="line">            int mul = (a[i] - &#x27;0&#x27;) * (b[j] - &#x27;0&#x27;);</span><br><span class="line">            int sum = mul + result[i + j + 1];</span><br><span class="line"></span><br><span class="line">            result[i + j] += sum / 10; // 进位</span><br><span class="line">            result[i + j + 1] = sum % 10; // 当前位</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 转换为字符串</span><br><span class="line">    string res;</span><br><span class="line">    for (int num : result) &#123;</span><br><span class="line">        if (res.empty() &amp;&amp; num == 0) continue; // 去掉前导0</span><br><span class="line">        res.push_back(num + &#x27;0&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return res.empty() ? &quot;0&quot; : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="高精度除法">高精度除法</h1><p><strong>原理</strong></p><ul><li>高精度除法较为复杂，通常需要模拟手工除法的过程。</li><li>从高位到低位逐位试除，记录商和余数。</li><li>余数用于下一次的试除。<br>代码如下：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; highPrecisionDivide(const string&amp; a, const string&amp; b) &#123;</span><br><span class="line">    string quotient, remainder;</span><br><span class="line">    int lenA = a.size(), lenB = b.size();</span><br><span class="line"></span><br><span class="line">    // 逐位试除</span><br><span class="line">    for (int i = 0; i &lt; lenA; i++) &#123;</span><br><span class="line">        remainder += a[i]; // 添加一位到余数</span><br><span class="line">        int temp = 0; // 用于存储当前的商</span><br><span class="line"></span><br><span class="line">        // 试除</span><br><span class="line">        while (remainder &gt;= b) &#123;</span><br><span class="line">            remainder = highPrecisionSubtract(remainder, b); // 减去除数</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quotient += to_string(temp); // 添加商的当前位</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 去掉前导0</span><br><span class="line">    quotient.erase(0, quotient.find_first_not_of(&#x27;0&#x27;));</span><br><span class="line">    remainder.erase(0, remainder.find_first_not_of(&#x27;0&#x27;));</span><br><span class="line"></span><br><span class="line">    return &#123;quotient, remainder&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前缀和</title>
      <link href="/2025/04/07/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
      <url>/2025/04/07/%E5%89%8D%E7%BC%80%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是前缀和">什么是前缀和</h1><p>前缀和是一种预处理技术，通过计算数组的前缀和数组，可以在常数时间内快速计算任意子数组的和。前缀和数组 prefix 定义为：<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>i</mi></msubsup><mi>a</mi><mi>r</mi><mi>r</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">prefix[i] = \sum_{j=0}^{i} arr[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">i</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.400382em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.964564em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></p><h1 id="一维前缀和">一维前缀和</h1><p>对于一个一维数组 arr，前缀和数组 prefix 的计算方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; prefix(n + 1, 0);</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">    prefix[i] = prefix[i - 1] + arr[i - 1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样可以轻松计算从arr[l]到arr[r]的和，即prefix[r]-prefix[l-1]</p><h1 id="二维前缀和">二维前缀和</h1><p>对于一个二维数组 arr，前缀和数组 prefix 的计算方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; prefix(n + 1, vector&lt;int&gt;(m + 1, 0));</span><br><span class="line">for (int i = 1; i &lt;= n; ++i) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= m; ++j) &#123;</span><br><span class="line">        prefix[i][j] = arr[i - 1][j - 1] + prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过前缀和数组，可以快速计算任意子矩阵 [x1, y1] 到 [x2, y2] 的和：<br>sum(x1,y1,x2,y2)=prefix[x2][y2]−prefix[x1−1][y2]−prefix[x2][y1−1]+prefix[x1−1][y1−1]</p><h1 id="前缀和的应用">前缀和的应用</h1><ul><li>子数组和</li><li>子矩阵和</li><li>区间查询</li></ul>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="/2025/04/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>/2025/04/07/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径">最短路径</h1><ul><li>Dijkstra<br>可以找到一个点到其他所有点的最短距离</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">typedef pair&lt;int, int&gt; pii;</span><br><span class="line">vector&lt;int&gt; dist(n, -1);</span><br><span class="line">vector&lt;bool&gt; visited(n);</span><br><span class="line">priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">dist[start] = 0;</span><br><span class="line">pq.push(&#123;start, 0&#125;);</span><br><span class="line">while(!pq.empty())&#123;</span><br><span class="line">    int u = pq.top().first;</span><br><span class="line">    int current_dist = pq.top().second;</span><br><span class="line">    pq.pop();</span><br><span class="line">    if(visited[u]) continue;</span><br><span class="line">    visited[u] = true;</span><br><span class="line">    for(int v = 0; v &lt; n; v++)&#123;</span><br><span class="line">        if(path[u][v] != -1)&#123;</span><br><span class="line">            int weight = path[u][v];</span><br><span class="line">            if(dist[u] + weight &lt; dist[v])&#123;</span><br><span class="line">                dist[v] = dist[u] + weight;</span><br><span class="line">                pq.push(&#123;v, dist[v]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>floyd<br>可以找到所有点之间的最短路径</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;int&gt;&gt; dist(n, vector&lt;int&gt;(n, -1));</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; path(n, vector&lt;int&gt;(n, -1));</span><br><span class="line">for(int i = 0; i &lt; n; i++)&#123;</span><br><span class="line">    dist[i][i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">for (int k = 0; k &lt; n; k++) &#123;     </span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (dist[i][k] != -1 &amp;&amp; dist[k][j] != -1) &#123;</span><br><span class="line">                if (dist[i][j] &gt; dist[i][k] + dist[k][j])&#123;</span><br><span class="line">                    dist[i][j] = dist[i][k] + dist[k][j];</span><br><span class="line">                    path[i][j] = k; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2025/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2025/04/07/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是动态规划">什么是动态规划</h1><p>动态规划（Dynamic Programming，简称 DP）是一种解决复杂问题的算法思想，通过将问题分解为更小的子问题，并将子问题的解存储起来以避免重复计算，从而提高算法的效率。动态规划通常用于优化问题，即在给定的约束条件下，找到最优解。</p><h1 id="动态规划的核心">动态规划的核心</h1><p>动态规划中状态是核心，通常用一个或多个变量表示，即dp[i]或dp[i][j]，然后用状态转移方程进行推导，但要注意初始状态和边界条件。</p><h1 id="使用场景">使用场景</h1><p>动态规划适用于具有以下特征的问题：</p><ul><li>最优子结构：<br>问题的最优解包含其子问题的最优解，即，可以通过子问题的最优解构造出原问题的最优解。</li><li>重叠子问题：<br>问题的递归求解过程中，存在大量的重复计算。动态规划通过存储子问题的解来避免重复计算。</li></ul><h1 id="常见应用">常见应用</h1><h2 id="背包问题">背包问题</h2><ul><li>0-1背包<br>dp[i][j] 表示前 i 种物品在容量为 j 的背包中能达到的最大价值<br>dp[0][j] = 0：不选任何物品时，价值为0。<br>dp[i][0] = 0：背包容量为0时，价值为0。<br>状态转移方程：<br>dp[i][j]=max(dp[i−1][j],dp[i−1][j−w[i]]+v[i])</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int knapsack_01(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; v, int W) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(w.size()+1, vector&lt;int&gt;(W+1, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= w.size(); ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= W; ++j) &#123;</span><br><span class="line">            if (j &gt;= w[i-1]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]] + v[i-1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[w.size()][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完全背包</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int knapsack_complete(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; v, int W) &#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(w.size()+1, vector&lt;int&gt;(W+1, 0));</span><br><span class="line">    </span><br><span class="line">    for (int i = 1; i &lt;= w.size(); ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= W; ++j) &#123;</span><br><span class="line">            if (j &gt;= w[i-1]) &#123;</span><br><span class="line">                dp[i][j] = max(dp[i-1][j], dp[i][j-w[i-1]] + v[i-1]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[w.size()][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以优化</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int knapsack_complete(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; v, int W) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(W + 1, 0);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; w.size(); ++i) &#123;</span><br><span class="line">        for (int j = w[i]; j &lt;= W; ++j) &#123;</span><br><span class="line">            dp[j] = max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="序列问题">序列问题</h2><ul><li>最长递增子序列(LIS)<br>dp[i] 表示以第 i 个元素结尾的最长递增子序列的长度<br>dp[i] = 1：每个元素自身可以看作一个长度为1的递增子序列。<br>状态转移方程：<br>dp[i]=max(dp[i],dp[j]+1)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int n = arr.size();</span><br><span class="line">vector&lt;int&gt; dp(n, 1);</span><br><span class="line">for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">    for (int j = 0; j &lt; i; ++j) &#123;</span><br><span class="line">        if (arr[j] &lt; arr[i]) &#123;</span><br><span class="line">            dp[i] = max(dp[i], dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最长公共子序列(LCS)<br>dp[i][j] 表示字符串 X 的前 i 个字符和字符串 Y 的前 j 个字符的最长公共子序列的长度。<br>dp[0][j] = 0：空字符串与任何字符串的最长公共子序列长度为0。<br>dp[i][0] = 0：空字符串与任何字符串的最长公共子序列长度为0。<br>状态转移方程：<br>如果 X[i−1]==Y[j−1]：<br>dp[i][j]=dp[i−1][j−1]+1<br>如果 X[i−1]!=Y[j−1]：<br>dp[i][j]=max(dp[i−1][j],dp[i][j−1])</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int m = X.size();</span><br><span class="line">int n = Y.size();</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));</span><br><span class="line"></span><br><span class="line">for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">    for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">        if (X[i - 1] == Y[j - 1]) &#123;</span><br><span class="line">            dp[i][j] = dp[i - 1][j - 1] + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2025/04/03/%E7%AE%97%E6%B3%95/"/>
      <url>/2025/04/03/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p><strong>时间复杂度</strong><br>-最坏时间复杂度W(n)<br>-平均时间复杂度A(n)<br>实例I <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> S的概率是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">{P_I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> ,</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mrow><mi>I</mi><mo>∈</mo><mi>S</mi></mrow></munder><msub><mi>P</mi><mi>I</mi></msub><mo>∗</mo><msub><mi>t</mi><mi>I</mi></msub></mrow><annotation encoding="application/x-tex">A(n)=\sum_{I\in S}{P_I}*{t_I} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.3717110000000003em;vertical-align:-1.321706em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.321706em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.07847em;">I</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><h1 id="基础算法">基础算法</h1><h2 id="暴力">暴力</h2><p>-五子棋对弈，5*5的棋盘上有多少种和棋的下法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">int mp[5][5];</span><br><span class="line">long long sum = 0;</span><br><span class="line">void check() &#123;</span><br><span class="line">    int a = 0;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; 5; j++) &#123;</span><br><span class="line">            if (mp[i][j] == 1) a++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a != 13) return;</span><br><span class="line">    //此时满足13-12 </span><br><span class="line">    int count = 0;</span><br><span class="line">    count += mp[0][0] + mp[1][1] + mp[2][2] + mp[3][3] + mp[4][4]; if (count % 5 == 0) return; count = 0;</span><br><span class="line">    count += mp[0][4] + mp[1][3] + mp[2][2] + mp[3][1] + mp[4][0]; if (count % 5 == 0) return; count = 0;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">        count += mp[i][0] + mp[i][1] + mp[i][2] + mp[i][3] + mp[i][4]; if (count % 5 == 0) return; count = 0;</span><br><span class="line">        count += mp[0][i] + mp[1][i] + mp[2][i] + mp[3][i] + mp[4][i]; if (count % 5 == 0) return; count = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    //满足平局 </span><br><span class="line">    sum++;</span><br><span class="line">&#125;</span><br><span class="line">void dfs(int num) &#123;//依次由从左往右，再到从上往下的顺序遍历</span><br><span class="line">    if (num == 25) &#123;//棋盘下满 </span><br><span class="line">        check();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int x = num / 5, y = num % 5;//换算成坐标</span><br><span class="line">    mp[x][y] = 0;</span><br><span class="line">    dfs(num + 1);</span><br><span class="line">    mp[x][y] = 1;</span><br><span class="line">    dfs(num + 1);</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    dfs(0);//从0开始，遍历所有结果</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;//3126376</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归">递归</h2><h2 id="二分">二分</h2><h2 id="双指针">双指针</h2><h2 id="排序">排序</h2><h2 id="分治">分治</h2><h2 id="贪心">贪心</h2><h2 id="前缀和">前缀和</h2><h2 id="差分">差分</h2><p><strong>LCM</strong><br><strong>ST表</strong><br><strong>搜索</strong></p><h1 id="走迷宫">走迷宫</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; map, int rx, int ry, vector&lt;vector&lt;int&gt;&gt;&amp; ans) &#123;</span><br><span class="line">queue&lt;pair&lt;int, int&gt;&gt; q;</span><br><span class="line">q.push(&#123; rx, ry &#125;);</span><br><span class="line">vector&lt;vector&lt;int&gt;&gt; directions = &#123; &#123;1,0&#125; ,&#123;0,1&#125;, &#123;-1,0&#125;, &#123;0,-1&#125; &#125;;</span><br><span class="line">ans[rx][ry] = 0;</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">pair&lt;int, int&gt; p = q.front();</span><br><span class="line">int x = p.first;</span><br><span class="line">int y = p.second;</span><br><span class="line">q.pop();</span><br><span class="line">for (auto dir : directions) &#123;</span><br><span class="line">if (x + dir[0] &gt;= 0 &amp;&amp; x + dir[0] &lt; n &amp;&amp; y + dir[1] &gt;= 0 &amp;&amp; y + dir[1] &lt; m) &#123;</span><br><span class="line">if (map[x + dir[0]][y + dir[1]] == 1) &#123;//表示有路</span><br><span class="line">if (ans[x + dir[0]][y + dir[1]] &gt; ans[x][y] + 1) &#123;</span><br><span class="line">ans[x + dir[0]][y + dir[1]] = ans[x][y] + 1;</span><br><span class="line">q.push(&#123; x + dir[0],y + dir[1]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> -算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2025/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/01/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="操作系统概述">操作系统概述</h1><p>操作系统是管理计算机硬件的软件。<br>计算机系统由以下4个部分组成：</p><ul><li>硬件： 为计算机提供基本的计算资源，如CPU、内存、I/O设备等；</li><li>操作系统： 控制硬件，并协调各个用户应用程序的硬件使用</li><li>应用程序： 确定了用户为解决计算问题而使用这些资源的方式；</li><li>用户</li></ul><p>I/O结构：</p><ul><li>同步I/O：I/O 启动后，在 I/O 完成之前，控制权不会返回给用户程序。</li><li>异步I/O：I/O 启动后，控制权将返回给用户程序，而无需等待 I/O 完成</li><li>DMA（直接内存访问）：设备控制器将数据块从缓冲区存储直接传输到主内存，无需 CPU 干预；每个块只生成一个中断，而不是每个字节生成一个中断</li></ul><h1 id="操作系统特征">操作系统特征</h1><ul><li>并发：并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。</li><li>共享：互斥共享和同步共享。</li><li>虚拟：虚拟技术把一个物理实体转换为多个逻辑实体。主要有两种虚拟技术：时（时间）分复用技术和空（空间）分复用技术</li><li>异步：进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。</li></ul><h1 id="操作系统的分类">操作系统的分类</h1><ul><li><p>图形用户界面（GUI）操作系统<br>特点：提供图形化的用户界面，易于使用，适合普通用户。</p></li><li><p>命令行界面（CLI）操作系统<br>特点：通过命令行输入命令，适合高级用户和系统管理员。</p></li><li><p>单内核（Monolithic Kernel）<br>特点：所有操作系统服务都运行在同一个内核空间，效率高，但可扩展性差。</p></li><li><p>微内核（Microkernel）<br>特点：核心服务运行在用户空间，内核只提供最基本的服务，可扩展性强，但效率较低。</p></li><li><p>混合内核（Hybrid Kernel）<br>特点：结合了单内核和微内核的优点，部分服务运行在内核空间，部分运行在用户空间。</p></li></ul><p>几种操作系统：</p><ul><li>实时操作系统</li><li>分布式操作系统：分布式系统是物理上独立的、可能是异构的、通过网络相连的一组计算机系统。网络是两个或多个系统之间的通信路径</li></ul><h1 id="内核态和用户态">内核态和用户态</h1><p>内核态能使用更高级的指令<br>内核态到用户态是操作系统主动让出CPU使用权<br>用户态到内核态是中断引起的</p><h1 id="中断与异常">中断与异常</h1><p>中断：是操作系统和硬件交互的关键部分，硬件可以通过系统总线随时发送信号到CPU触发中断，当CPU被中断时，它停止正在做的事情，并立即转到固定位置执行中断处理程序，中断处理程序是操作系统的一部分，它负责处理中断，并恢复CPU到中断前的状态<br>中断分为内中断(异常)和外中断。<br>异常：陷阱、陷入；故障；终止<br>外中断：时钟中断；I/O中断请求</p><h1 id="系统调用">系统调用</h1><p>系统调用是用户程序与操作系统内核之间的一种通信机制。当用户程序需要操作系统提供的服务时（如文件操作、进程控制等），它会通过系统调用向操作系统内核发出请求。<br>系统调用的类型：</p><ul><li>进程控制：<ul><li>创建和终止进程</li><li>加载、执行</li><li>获取进程属性，设置进程属性</li><li>等待事件，信号事件</li><li>分配和释放内存</li></ul></li><li>文件管理<ul><li>创建文件，删除文件</li><li>打开、关闭文件</li><li>读、写、重定位</li><li>获取文件属性，设置文件属性</li></ul></li><li>设备管理<ul><li>请求设备，释放设备</li><li>读、写、重定位</li><li>获取设备属性，设置设备属性</li><li>逻辑增加或移除设备</li></ul></li><li>信息维护<ul><li>获取时间和日期，设置时间和日期</li><li>获取系统数据，设置系统数据</li><li>获取进程、文件或设备属性</li><li>设置进程、文件或设备属性</li></ul></li><li>通信<ul><li>创建、删除通信连接</li><li>发送、接收消息</li><li>传输状态信息</li><li>增加或移除远程设备</li></ul></li><li>保护<ul><li>获取文件权限</li><li>设置文件权限</li></ul></li></ul><h1 id="进程">进程</h1><p>程序：是静态的，就是个存放在磁盘里的可执行文件，一系列的指令集合。<br>进程：是动态的，是程序的一次执行过程。<br>特点：</p><ul><li>独立性：每个进程都有自己的独立地址空间和资源。</li><li>并发性：多个进程可以同时运行，操作系统通过时间片轮转等方式调度进程。</li><li>隔离性：进程之间的地址空间是隔离的，一个进程的崩溃不会影响其他进程。<br>优点：</li><li>资源隔离：进程之间的资源隔离可以防止一个进程的错误影响其他进程。</li><li>稳定性：进程的隔离性提高了系统的稳定性。<br>缺点：</li><li>上下文切换开销大：进程之间的上下文切换需要保存和恢复整个进程的状态，开销较大。</li><li>通信复杂：进程之间的通信需要通过进程间通信（IPC）机制，如管道、消息队列、共享内存等，通信开销较大。</li></ul><h1 id="线程">线程</h1><p>线程是进程中的一个执行单元，是操作系统调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源，但每个线程有自己的执行栈和程序计数器。<br>特点：</p><ul><li>轻量级：线程是轻量级的，创建和切换线程的开销较小。(同一进程下线程切换比进程小，从一个进程的线程切换到另一个进程的线程就不一样了)</li><li>并发性：多个线程可以并发执行，共享进程的资源。</li><li>共享性：线程共享进程的地址空间和资源，线程之间的通信开销较小。<br><strong>一对一模型</strong><br>在一对一模型中，每个用户级线程直接映射到一个内核级线程。这意味着每个用户级线程都有一个对应的内核级线程。这种模型的优点是线程的调度由操作系统内核直接管理，可以充分利用多核处理器的并行性<br><strong>一对多模型</strong><br>在一对多模型中，多个用户级线程映射到一个内核级线程。这意味着多个用户级线程共享一个内核级线程。这种模型的优点是线程的创建和切换开销较小，适合需要大量线程的应用。<br><strong>多对多模型</strong><br>混合模型结合了一对一和一对多模型的优点。在这种模型中，多个用户级线程映射到多个内核级线程。这种模型既保留了用户级线程的高效性，又利用了内核级线程的并行性。</li></ul><h1 id="调度算法">调度算法</h1><p><strong>FCFS先到先服务调度</strong></p><ul><li>算法思想：先到达的进程先服务</li><li>非抢占式</li><li>公平、实现简单</li><li>等待时间长，对长作业有利，对短作业不利<br><strong>SJF最短作业优先调度</strong></li><li>算法思想：短进程优先</li><li>非抢占式或抢占式</li><li>等待时间短</li><li>会长进程饥饿<br><strong>RR时间片轮转调度</strong></li><li>轮流让就绪队列的进程依次执行一个时间片，时间片时间应大于80%进程时间</li><li>抢占式</li><li>公平，响应快，适用于分时操作系统</li><li>高频率的进程切换会有一定开销<br><strong>优先级调度</strong></li><li>优先级高的先运行</li><li>非抢占式或抢占式</li><li>用优先级区分任务的重要程度，适用于实时操作系统</li><li>可能会饥饿<br><strong>多级反馈队列调度</strong></li><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大，新进程到达时先进入第1级队列，按FCFS原则等待时间片，若用完进程没结束，进入下一级队列队尾，只有第k级队列为空时才会为k+1级队头的进程分配时间片</li><li>抢占式</li><li>对各类型进程相对公平，每个新到达的进程都可以很快得到响应，不必估计进程的运行时间</li><li>一般不说缺点，可能饥饿</li></ul><h1 id="进程同步">进程同步</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    entry section;//进入区</span><br><span class="line">    critical section;//临界区</span><br><span class="line">    exit section;//退出区</span><br><span class="line">    remainder section;//剩余区</span><br><span class="line">&#125;while(true)</span><br></pre></td></tr></table></figure><p>当一个进程在临界区时，其他进程不允许在它们的临界区内执行<br><strong>临界区问题解决方案应满足的要求</strong></p><ul><li>互斥</li><li>进步，有空让进</li><li>有限等待，发出请求后等待时间有限<br><strong>Peterson解决方案</strong></li></ul><div style="display: flex; justify-content: space-between;">  <div style="width: 48%;">    <strong>P<sub>i</sub>进程</strong>     <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[i] = true;</span><br><span class="line">turn = j;</span><br><span class="line">while(flag[j] &amp;&amp; turn == j);</span><br><span class="line">critical section;</span><br><span class="line">flag[i] = false;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>  </div>  <div style="width: 48%;">    <strong>P<sub>j</sub>进程</strong>        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flag[j] = true;</span><br><span class="line">turn = i;</span><br><span class="line">while(flag[i] &amp;&amp; turn == i);</span><br><span class="line">critical section;</span><br><span class="line">flag[j] = false;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure>  </div></div><p>缺点：只能在2个进程时使用<br><strong>硬件指令</strong></p><ul><li>中断屏蔽方法<br>开关中断</li><li>TestAndSet指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bool TestAndSet(bool *lock)&#123;</span><br><span class="line">  bool old;</span><br><span class="line">  old = *lock;</span><br><span class="line">  *lock = true;</span><br><span class="line">  return old;</span><br><span class="line">&#125;</span><br><span class="line">while(TestAndSet(&amp;lock));</span><br><span class="line">critical section;</span><br><span class="line">lock = false;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><ul><li>CAS指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swap(bool *a, bool *b)&#123;</span><br><span class="line">  bool temp;</span><br><span class="line">  temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br><span class="line">bool old = true;</span><br><span class="line">while(old == true)</span><br><span class="line">  Swap(&amp;lock, &amp;old);</span><br><span class="line">critical section;</span><br><span class="line">lock = flase;</span><br><span class="line">remainder section;</span><br></pre></td></tr></table></figure><p><strong>互斥锁</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">acquire()&#123;</span><br><span class="line">  while(!available);</span><br><span class="line">  available = false;</span><br><span class="line">&#125;</span><br><span class="line">release()&#123;</span><br><span class="line">  available = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要缺点：忙等待<br><strong>信号量</strong></p><ul><li>wait(S)，P(S)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void wait(int S)&#123;</span><br><span class="line">    while(S&lt;=0);</span><br><span class="line">    S = S - 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- signal(S)，V(S)</span><br><span class="line">void signal(int S)&#123;</span><br><span class="line">    S = S + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：可能产生死锁</p><h1 id="管程">管程</h1><p>类似一个类，基本特征如下：</p><ul><li>局部于管程的数据只能被局部于管程的过程访问</li><li>一个进程只能通过调用管程中的过程才能进入管程访问共享数据</li><li>每次仅允许一个进程在管程内执行某个内部过程</li></ul><div style="display: flex; gap: 20px;">  <div style="flex: 1;">    <pre><code class="monitor">monitor ProducerConsumer  condition full, empty;  int count = 0;  void insert(Item item)&#123;    if(count == N)&#123;      wait(full);    &#125;    count++;    insert_item(item);    if(count == 1)&#123;      signal(empty);    &#125;  &#125;  Item remove()&#123;    if(count == 0)&#123;      wait(empty);    &#125;    count--;    if(count == N - 1)&#123;      signal(full);    &#125;    return remove_item();  &#125;    </code></pre>  </div>  <div style="flex: 1; display: flex; flex-direction: column; gap: 20px;">    <div>      <pre><code class="producer">producer()&#123;  while(1)&#123;    item = product;    ProducerConsumer.insert(item);  &#125;&#125;      </code></pre>    </div>    <div>      <pre><code class="consumer">consumer()&#123;  while(1)&#123;    item = ProducerConsumer.remove();    consume_item();  &#125;&#125;      </code></pre>    </div>  </div></div><h1 id="死锁">死锁</h1><p>死锁的四个基本条件：</p><ul><li>互斥条件</li><li>不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放</li><li>请求和保持条件</li><li>循环等待条件</li></ul><h1 id="死锁的处理">死锁的处理</h1><h2 id="预防死锁">预防死锁</h2><ul><li>破坏互斥条件：<br>将只能互斥使用的资源改造为允许共享使用，则系统不会陷入死锁。<br>缺点：并不是所有资源都可以改造成可共享的资源。</li><li>破坏不剥夺条件：<br>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，等之后重新申请。<br>方案二：当某个进程需要的资源被其他进程所占有时，可以由操作系统协助将想要的资源强行剥夺。(这种方法一般考虑各进程的优先级)<br>缺点：<ul><li>实现复杂。</li><li>释放已获得资源可能造成前一阶段工作的失效，只适用易保存和恢复的资源。</li><li>反复申请和释放增加系统开销，减低系统吞吐量。</li><li>采用方案一，只要暂时得不到某个资源，之前的资源就会放弃，重新申请。如果已知发生就会导致进程饥饿。</li></ul></li><li>破坏请求和保持条件：<br>采用静态分配方法，即进程在运行前一次申请完它所需要的全部资源。<br>缺点：有些资源可能只需要很短时间，因此如果整个运行期间都一直保持着所有资源，就会导致严重浪费，资源利用率极低。还有可能导致某些进程饥饿。</li><li>破坏循环等待条件<br>采用顺序资源分配法，先给系统中的资源编号，每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。<br>缺点：<ul><li>不方便增加新的设备，需要重新编号。</li><li>进程实际使用资源的顺序可能和编号递增顺序不一致。</li><li>必须按规定次序申请资源，用户编程麻烦。</li></ul></li></ul><h2 id="避免死锁">避免死锁</h2><p>处于安全状态一定不死锁，处于非安全状态，不一定死锁。<br>银行家算法：<br>1 if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ≤ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>e</mi><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">need_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> go to step 2<br>2 if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ≤ available go to step 3<br>3 available = available - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>4 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">allocation_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>l</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><msub><mi>n</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">allocation_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>5 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>e</mi><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">need_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>e</mi><mi>e</mi><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">need_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> - <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>s</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">request_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><br>6 调用安全算法，检查此次资源分配后系统是否处于安全状态。若安全，才正式分配；否则，恢复相应数据，让进程阻塞等待。</p><h2 id="死锁检测和解除">死锁检测和解除</h2><p>检测有无死锁，有就立即解除。<br>检测死锁的算法：找出既不阻塞又不是孤点的进程，且该有向边对应资源的申请数量小于等于系统中已有空闲资源数量。消去它所有的请求边和分配边，使之成为孤点，若能消去所有边就没有死锁。<br>解除死锁的方法有：</p><ul><li>资源剥夺法：挂起(暂时放到外存上)某些死锁进程，并抢占它的资源。</li><li>撤销进程法：强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。</li><li>进程回退法：让一个或多个死锁进程回退到避免死锁的地步。</li></ul><h1 id="内存管理">内存管理</h1><p>物理地址：是内存单元的实际位置<br>逻辑地址：程序在运行时使用的代码，也叫虚拟地址</p><p><strong>覆盖技术</strong><br>将内存分为固定区和覆盖区，将程序分为多个模块，经常使用的放在固定区，不经常使用的部分当需要使用的时候再放到覆盖区中<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%A6%86%E7%9B%96%E6%8A%80%E6%9C%AF.png" alt=""><br>必须由程序员声明覆盖结构，操作系统完成自动覆盖。对用户不透明，增加用户编程负担。已成为历史。</p><h2 id="交换技术">交换技术</h2><p>设计思想：内存紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存(进程在内存与磁盘间动态调度)</p><h2 id="内存空间的分配">内存空间的分配</h2><h3 id="连续分配管理方式">连续分配管理方式</h3><p>连续分配：用户进程分配的必须是一个连续的内存空间</p><h4 id="单一连续分配">单一连续分配</h4><p>将内存分为系统区和用户区。系统区用于存放操作系统，用户区用于存放用户进程相关数据。但内存只能有一道用户程序。<br>优点：实现简单；无外部碎片；不一定需要采取内存保护。<br>缺点：只能用于单用户、单任务的操作系统；有内部碎片；存储器利用率低。</p><h4 id="固定分区分配">固定分区分配</h4><p>将整个用户区分为若干个固定大小的分区。<br>分区大小相等：缺乏灵活性，但很适用于用一台计算机控制多个相同对象的场合<br>分区大小不等：增加了灵活性。<br>操作系统需要建立一个数据结构————分区说明表，来实现各个分区的分配和回收。<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E5%8C%BA%E8%AF%B4%E6%98%8E%E8%A1%A8.png" alt=""><br>优点：实现简单；无外部碎片<br>缺点：当用户程序过大，所有分区都不能符合要求，就不得不采用覆盖技术，但这会降低性能；会产生内部碎片，内存利用率低。</p><h4 id="动态分区分配">动态分区分配</h4><p>在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。<br>用空闲分区表或空闲分区链来记录内存的使用情况。<br><strong>动态分区分配算法</strong><br>首次适应算法：每次从低地址开始查找，找到第一个能满足大小的空闲分区。<br>空闲分区按地址递增次序连接。<br>最佳适应算法：优先使用更小的空闲区。<br>空闲分区按容量递增次序连接。<br>最坏适应算法：优先使用最大的连续空闲区。<br>空闲分区按容量递减次序连接。<br>邻近适应算法：从上次查找结束的位置开始检索。<br>空闲分区以地址递增的顺序排列(可排成一个循环链表)。</p><h3 id="非连续分配管理方式">非连续分配管理方式</h3><h4 id="分页存储">分页存储</h4><p>将内存分为一个个大小相等的分区，每个分区就是一帧/块；将进程的逻辑地址空间也分为与帧大小相等的一个个部分，每个部分就是一个页。<br>一个进程对应一张页表；进程的每个页对应一个页表项，每个页表项由页号和块号组成；页表记录进程页和实际存放的内存块之间的映射关系。<br>将逻辑地址拆分为页号和页内偏移量，就可以通过页号查询页表得到起始位置，再通过偏移量知道实际地址。<br><strong>地址计算</strong><br>设页面大小为L。</p><ol><li>计算页号P和页内偏移量W，(十进制就得算：P=A/L，W=A%L；二进制可以得到P和W)</li><li>比较P和页表长度M，P ≥ M，则产生越界中断，否则继续执行。</li><li>P * L + W即为实际地址(设从0开始)</li></ol><p><strong>TLB(联想寄存器)</strong><br>TLB是用来存放最近访问的页表项的副本的，也叫快表。<br>访问逻辑地址时，TLB有就直接访问，没有命中就按之前的方法访问物理地址，并将其存入快表中。</p><h4 id="两级页表">两级页表</h4><p>单级页表的问题：</p><ol><li>页表必须；连续存放，因此当页表很大时，需要哦占用很多个连续的页框</li><li>没必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问几个特定的页面</li></ol><p>按地址结构将逻辑地址拆分为三部分：一级页表，二级页表，页内偏移量，解决问题一<br>需要内存时才把页面调入内存，在页表项中添加一个标志位，用于表示是否已经调入内存，解决问题二</p><h4 id="分段存储">分段存储</h4><p>将逻辑地址分为段号和段内地址。需要为每个进程建立一张段映射表，简称段表。段表有段号(隐含的，不占存储空间)、段长、基址。<br>段长长度=段内块号长度。<br>段内地址不能大于等于段长。<br><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8.png" alt=""></p><h1 id="虚拟内存">虚拟内存</h1><p>传统存储管理有2个问题：</p><ol><li>一次性：作业必须一次性全部装入内存后才能开始运行。这导致作业很大时，不能全部装入内存，导致大作业无法运行；当大作业需要运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致多道程序并发度下降。</li><li>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的，暂时用不到的数据，浪费了宝贵的内存资源。</li></ol><p>局部性原理：时间局部性 &amp; 空间局部性<br>基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存。当程序执行时，当被访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存，然后继续执行程序。若内存不够，由操作系统负责将内存中暂时用不到的信息换出到外存。<br>虚拟内存的主要特征：</p><ul><li>多次性：允许被分为多次调入内存</li><li>对唤性：允许将作业换入、换出</li><li>虚拟性：从逻辑上扩充了内存的容量</li></ul><p>虚拟内存技术，允许一个作业分多次调入内存，采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在离散分配的内存管理方式基础上。</p><h2 id="复制读写">复制读写</h2><p>fork()允许父子进程共享内存中的同一个页面，这些共享进程会被标记为复制读写页面，只要有一个进程要改变共享页面，就会创建一个共享进程的副本。<br>vfork()创建子进程时，子进程与父进程共享同一内存空间。这意味着子进程对内存的修改会直接影响父进程。</p><h2 id="请求页式">请求页式</h2><p>页表中添加有效位，表示是否有效无效就是发生了缺页中断，<strong>缺页中断</strong>是因为当前执行的指令想要访问的目标页面未调入内存而产生的。<br>处理缺页中断的步骤：请求调页，获取被放入的位置，将要执行的页面调入内存，更改有效位，重新执行引起缺页中断的指令。<br>给页表项添加一个修改位，表示是否被修改过，没有就是放入空页表，有就是要发生置换。</p><h3 id="页面置换算法">页面置换算法</h3><p><img src="/img/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95.png" alt=""><br><strong>先进先出置换算法(FIFO)</strong>：<br>把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时选择队头页面页面即可。<br><strong>最佳置换算法(OPT)</strong>：<br>每次选择淘汰的页面将是以后永不使用，或者在最长时间内不再访问的页面。<br><strong>最近最久未使用置换算法(LRU)</strong>：<br>每次淘汰的页面是最近最久未使用的页面。赋予每个页面对应的页表项一个LRU位，来访问字段记录该页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择现有页面中t值最大的。<br><strong>第二次机会置换算法(CLOCK)</strong>：<br>给页表项加一个访问位用来记录访问次数，再将内存中的页面连成一个循环队列，当被访问时，0的时候就可以置换它，1的时候将它设置为0，再给它一次机会。<br><strong>改进的第二次机会算法</strong>：<br>给页表项添加两位，一位是访问位，一位是修改位，还是循环队列。(0,0)表示替换的最佳位置(0,1)表示不是很好的替换位置(1,0)表示不久可能要用(1,1)表示最坏的置换位置。<br>第一轮扫描扫到第一个(0,0)的页面进行替换，本轮不修改任何标记位。<br>第一轮失败，则进行第二轮，找第一个(0,1)的页面，扫描过的页面访问位设为0。<br>第二轮失败，则进行第三轮，找第一个(0,0)的页面进行置换，不修改任何标记位。<br>第三轮失败，则进行第四轮，找第一个(0,1)的页面进行置换。<br><strong>基于计数的页面置换算法</strong>：<br>为每个页面的引用次数保存一个计数器，接下来有2个方案：</p><ul><li>最不经常使用页面置换算法(LFU)：选择具有最小计数的页面置换。但计数大的会保留在内存中，可以定期将计数右移一位，形成以指数衰减的平均使用计数。</li><li>最经常使用页面置换算法(MFU)：具有最小计数的页面可能刚被引入并且尚未使用</li></ul><p><strong>页面缓冲算法</strong><br>固定分配：每个进程分配一组固定数目的物理块，进程运行期间不再改变。<br>可变分配：先为每个进程分配一定数目的物理块，进程运行期间，可根据情况做适当的增加或减少。<br>全局分配：可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。<br>局部分配：发生缺页时只能选进程之间的物理块进行置换。<br><strong>抖动</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
